{"./":{"url":"./","title":"はじめに","keywords":"","body":"Python×DjangoのWEBサイト作成&テスト自動化を通して実践スキルを学ぼう！ 事前準備 VSCodeインストール Dockerインストール Gitインストール、GitHubアカウントの作成 今回の流れ（画面作成 ～ テスト） Djangoフレームワークを用いて、商品の検索や詳細情報の確認を行うことの出来る画面を作成。その後、テストコードを作成し実際に作成した画面に対するテストまで実施します。 以下の2画面の作成と、そのテスト実施を予定しています。 商品情報検索画面 商品情報詳細画面 手順 全体手順としては以下の流れで進めます。 デモアプリクローン アプリケーションコード修正 デモアプリの起動・動作確認 テストコード作成 テスト実施 後片付け "},"Section2.html":{"url":"Section2.html","title":"1. デモアプリクローン","keywords":"","body":"デモアプリダウンロード 当手順では以下の赤枠部分を実施します。 Githubリポジトリ表示 以下リンクよりデモアプリのあるGithubリポジトリにアクセスします。 URL:https://github.com/miracleave-ltd/meet-up-22_django ソースコードダウンロード Codeボタンより、Zipファイルをダウンロードします。 ソースコード展開 ダウンロードしたZipファイルを任意のフォルダに展開してください。 ※次の手順を進めるに当たり、展開されたフォルダをVSCodeで開くようお願いします。 サイトを立ち上げてみる デモアプリを修正していない状態で、一度サイトを起動してみましょう。 Dockerの起動 コマンドをVSCodeのターミナル上から実施し、Dockerの起動を行います。 以下イメージのように Creating ... done と表示されると成功です。 docker-compose up -d --build スーパーユーザーの作成 以下コマンドを実施し、管理サイトにて使用するユーザー情報を作成します。 docker-compose run web python manage.py createsuperuser 設定する値はそれぞれ以下の通りです。 ユーザー名：admin メールアドレス：未設定（そのままEnter） パスワード：任意の値（単純すぎるものは警告が出ます） 上記までの手順で、ブラウザに以下URLを入力することで画面を参照することが出来ます。 http://localhost:7777 "},"Section3.html":{"url":"Section3.html","title":"2. アプリケーションコード修正を行う前に","keywords":"","body":"アプリケーションコード修正を行う前に デモアプリの中身について説明します。 前提 その1 本日は、以下2画面の実装を行います。 一部動作しない状態となっていますので、動作するように修正いただきつつ、途中ポイントの説明をさせていただきます。 商品情報検索画面 商品情報詳細画面 前提 その2 今回使用するモデルの内容は、それぞれ以下の通りです。 商品名称などを保持、また商品に紐づく画像を保持する2テーブルを準備しております。 app\\product\\models\\product.py from django.db import models class Product(models.Model): code = models.CharField(max_length=3, verbose_name='商品コード', primary_key=True, db_index=True) name = models.CharField(max_length=100, verbose_name='商品名') explanation = models.CharField(max_length=300, verbose_name='商品説明') price = models.IntegerField(default=0, verbose_name='商品価格') create_at = models.DateTimeField(auto_now_add=True, verbose_name='作成日時') update_at = models.DateTimeField(auto_now=True, verbose_name='更新日時') create_user = models.CharField(max_length=10, verbose_name='作成者', blank=True, null=True) update_user = models.CharField(max_length=10, verbose_name='更新者', blank=True, null=True) app\\product\\models\\image.py from django.db import models class Image(models.Model): product = models.ForeignKey('product.product', on_delete=models.SET_NULL, related_name='r_prdct_img', verbose_name='商品情報', blank=True, null=True) image = models.ImageField(upload_to='images/', verbose_name='商品画像', blank=True, null=True) ポイント ForeignKeyとは、異なるテーブルに対して設定し「1対多」の親子関係を持たせることの出来るDjangoの機能です。 今回事前に用意した2テーブルについてもProductを親、Imageを子としてForeignKeyを設定しています。 Productテーブル 商品コード 商品名 ・・・ 10 PC ・・・ 11 マウス ・・・ 12 キーボード ・・・ Imageテーブル ID 商品情報(ForeignKey) 商品画像 1 10 画像1-1 2 10 画像1-2 3 11 画像2 4 12 画像3 ForeignKeyを設定することで、親子テーブル間で以下のようなデータ取得が可能となります。 〇 Image(子)に紐づくProduct(親)の取得 image = Image.objects.get(id=1) product = image.product 〇Product(親)に紐づくImage(子)の取得 product = Product.objects.get(code=10) images = product.r_prdct_img.all() for image in images: # 任意の処理 〇Product情報を元にImageの絞り込み hoge = Product.objects.get(code=10) images = Image.objects.filter(product=hoge) 前提 その3 イチからプロジェクトを作成する場合は、以下手順を実施する必要があります。 デモアプリでは実施済みの状態ですので、当手順自体はスキップしてください。 コマンド django-admin.py startproject config . コマンド python manage.py startapp app コマンド cd app コマンド python ../manage.py startapp product config\\settings.py import os # 一部省略 TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] # 一部省略 LANGUAGE_CODE = 'ja' TIME_ZONE = 'Asia/Tokyo' # 一部省略 STATICFILES_DIRS = [ os.path.join(BASE_DIR, 'statics') ] STATIC_ROOT = os.path.join(BASE_DIR, 'static') STATIC_URL = '/static/' app\\product\\apps.py name = 'app.product' "},"Section4.html":{"url":"Section4.html","title":"3. アプリケーションコード修正（商品情報検索画面）","keywords":"","body":"アプリケーションコード修正（商品情報検索画面） 当手順では以下赤枠部分の内、商品情報検索画面の入力フォームにCSSを適用します。 CSS適用に際して、widget_tweaksプラグインを使用しますので、その説明も併せて行います。 当画面に関連するソースファイル app\\product\\filter\\product_search_filter.py app\\product\\views\\product_search_view.py app\\product\\urls.py templates\\product\\product_search.html ←修正対象 templates\\product\\component\\product_field.html ←修正対象 Template（HTML）の修正 各フォーム項目表示用コンポーネントを作成し、そのコンポーネントを検索画面に表示されるよう修正します。 なお、コンポーネント内でwidget_tweaksを使用します。 templates\\product\\component\\product_field.html {% load widget_tweaks %} {{ field.label }} {% if field.errors %} {% render_field field class=\"form-control is-invalid\" %} {% else %} {% render_field field class=\"form-control\" %} {% endif %} {% for err_msg in field.errors %} {{ err_msg }} {% endfor %} ポイント widget_tweaksプラグインを読み込むことで、該当HTMLで使用することが可能です。 以下のようにrender_fieldタグで表示したい項目を囲み、class指定をしてあげることでHTMLを書くようにCSSを適用することが出来ます。 templates\\product\\product_search.html - 15Line~ 変更前 {{ filter.form.as_p }} 変更後 {% include \"product/component/product_field.html\" with field=filter.form.code %} {% include \"product/component/product_field.html\" with field=filter.form.name %} ポイント フォームなど、繰り返し出現する記載については上記のように別パーツ化をして includeタグで呼び出すことによりソースの記述量を減らすことが可能です。 with xxxx=~~ と記載することで、インクルードするHTMLへパラメータを渡すことも出来ます。 画面確認 以下URLをブラウザにて入力し画面を表示します。 http://localhost:7777 商品情報検索ボタンを押下してみてください。 ※ 最終差し替え予定 ※ 検索画面が表示されレイアウトがイメージの通り変更されていれば成功です。 データの登録 検索画面を表示することが出来ましたが、肝心のデータが0件の為、試しに1件データを登録します。 画面右上のDjango管理サイトというリンクを押下してください。 以下のような画面が表示される為、2ページ目の手順にて作成したスーパーユーザーの情報を入力しログインします。 管理サイトという画面が表示される為、Products、Imagesのリンクを押下しそれぞれデータを作成します。任意の値で問題ありません。なお、手頃な画像をお持ちで無い方はappフォルダと同階層にdataというフォルダを用意しておりますので、そちらに格納された画像を使用してください。 データ登録後、作成した検索画面にて検索を行うと、登録した商品情報が表示されることを確認できます。 "},"Section5.html":{"url":"Section5.html","title":"4. アプリケーションコード修正（商品情報詳細画面）","keywords":"","body":"アプリケーションコード修正（商品情報詳細画面） 商品情報詳細画面へ遷移出来るようURL設定を修正し、商品情報詳細画面に対するView機能を実装します。 注意事項 商品情報検索画面作成時に追加／修正したファイルはそのままとしてください。 当画面に関連するソースファイル app\\product\\views\\product_detail_view.py ←修正対象 app\\product\\urls.py templates\\product\\product_detail.html ←修正対象 templates\\product\\product_search.html ←修正対象 Template（HTML）の修正 templates\\product\\product_search.htmlの51Line目付近へ、詳細ボタン押下時に呼び出されるURL定義を追記します。 変更前 詳細 変更後 詳細 ※ここまでの手順で検索画面にて、検索ボタンを押下するとどうなるか見てみましょう。 viewの修正 app\\product\\views\\product_detail_view.py に詳細ボタン押下時の処理を実装します。 from app.product.models.product import Product from django.views.generic import DetailView class ProductDetailView(DetailView): model = Product template_name = 'product/product_detail.html' urls.pyの修正 app\\product\\urls.py に詳細画面用のviewをインポートし urlpatternsに詳細画面へ遷移する為のURL文字列とインポートしたviewを設定します。 from django.urls import path from app.product.views.product_search_view import ProductSearchListView # 追記 from app.product.views.product_detail_view import ProductDetailView from django.views.generic import TemplateView app_name = 'product' urlpatterns = [ path('', TemplateView.as_view(template_name='product/product_top.html'), name='top'), path('search/', ProductSearchListView.as_view(), name='product_search'), # 追記 path('detail/', ProductDetailView.as_view(), name='product_detail'), ] ポイント WEBサイトの多くは DBからの情報を絞り込んで検索結果を表示する 検索結果の内、単一の情報の詳細内容を表示する 画面に入力された内容を元にDBへ情報を登録・更新する という機能を持っています。 上記のような定型的な処理について、同じようなコードを書かなくても済むようあらかじめDjangoに処理が定義されています。 その処理のことを汎用ビューと呼び、関数で定義されていれば「関数ベース汎用ビュー」、クラスで定義されていれば「クラスベース汎用ビュー」と呼びます。 クラスベース汎用ビューの内、何点かピックアップして紹介します。 DetailView 個別詳細ページ実装時に使用する汎用ビューとなります。 modelに定義されたテーブルより、URLに指定されたプライマリーキーを元に絞り込まれたレコードを1件取得します。 views.py from django.views.generic import DetailView from mymodel.model import MyModel class MyDetailView(DetailView): model = MyModel urls.py urlpatterns = [ path('', MyDetailView.as_view()), ] CreateView／UpdateView CreateViewは、新たにレコード追加するフォームを定義することが出来るビューとなります。 UpdateViewは、すでに存在するデータを更新するフォームを定義することが出来るビューとなります。 form_valid , form_invalidというメソッドが定義されているので、エラーの有無によって独自の処理を実施することが可能です。 views.py from django.views.generic import CreateView from mymodel.model import MyModel from forms import MyModelForm class MyCreateView(CreateView): model = MyModel form_class = MyModelForm def form_valid(self, form): ''' 入力内容チェックにエラーがない場合 ''' messages.success(self.request, \"保存しました\") return super().form_valid(form) def form_invalid(self, form): ''' 入力内容チェックにエラーがある場合 ''' message.warning(self.request, \"保存できませんでした\") return super().form_invalid(form) forms.py from django import forms from mymodel.model import MyModel class MyModelForm(forms.ModelForm): class Meta: model = MyModel exclude = ['create_at', 'update_at', 'create_user', 'update_user',] urls.py urlpatterns = [ path('create/', MyCreateView.as_view()), ] 画面確認 以下URLをブラウザへ入力し画面を表示します。 http://localhost:7777 商品情報検索結果に表示された詳細ボタンを押下すると、作成した商品情報詳細画面へ遷移するようになります。 "},"Section8.html":{"url":"Section8.html","title":"5. Pytest","keywords":"","body":"Pytest\b 当手順では以下の赤枠部分を実施します。 この手順ではPytestを実行させたときにどんな動きをするのか。また、失敗した際にどんな内容で表示されるのかを確認したいと思います。 なお、ここで確認できた内容を踏まえて、次のセクションではテストに関する簡単な問題を出題します。 問題の回答についても用意しておりますので、ぜひ問題にトライしてみましょう！ 今回用意したテストファイル app/product/test/conftest.py pytestでテスト実行する際のDBアクセス設定を共通部品として記述しています。 app/product/test/crud_test.py データのCreate, Read, Updateのテストを記述しています。 app/product/test/views_test.py Viewに対しテストコードを記述する為、pytest-djangoという拡張機能を使用します。 ・正しいtemplateを使用しているか ・正しいステータスコードが返却されているか についてのテストを実施します。 Pytestの挙動 Pytestはターミナル上で以下のコマンドを実行すると、自動でテストコードを感知し実行してくれます。 # プロジェクト配下ですべてのテストを実行するとき pytest . # テストケースを指定して実行したいとき pytest app/product/tests.py 【テスト成功時】 成功となった際には以下のようにターミナルへ出力され、実行したテストファイルやメソッドの数、テストの所要時間などが確認出来ます。 【テスト失敗時】 テストに失敗してしまった際にも同様にターミナルへ出力されますが、 以下のようにどこの箇所でどんなエラーが発生しているかを教えてくれます！ 上記の画像では、 「test_create」 関数で 「assert result == expected」の箇所で 「AssertionError」のエラー（例外）が発生している 「１つがfailed(失敗)、２つがパス（成功）している」 ということが分かります。 このように出力される結果が容易にテスト結果を把握できます。 "},"Section9.html":{"url":"Section9.html","title":"6. Pytest エラーの修正 -問題-","keywords":"","body":"Pytest エラーの修正 -問題- 前のページの内容を踏まえて、簡単な問題を用意しました。 まずは、実際に発生するエラーを修正してみましょう。 以下のコマンドを実行して下さい。 docker-compose exec web pytest 実行すると、現在以下の内容がターミナルに出力されていると思います。 3 failed, 4 passe こちらのエラーは、7件のテストのうち３件が失敗し、4件が成功しているという意味になります。 発生しているエラー内容については以下でも補足しています。補足内容も参考にしつつ、7件のテストを成功させてみましょう。 問題 Question１ 対象ファイル：app/product/test/crud_test.py 対象関数：test_create テスト内容：1件のデータを登録し、登録されているデータ数が1件であることを確認しています。 エラー内容：期待しているデータ件数が取得したデータ件数と一致していない。（期待値の設定箇所expected） cursor = def test_create(cursor): insert_query = \"insert into product_product values('99','テストプラン','これはテストプランです', '99999', '2021-08-18','2021-08-19','createuser','updateuser');\" cursor.execute(insert_query) # 件数確認 counts_query = \"select count(1) from product_product;\" cursor.execute(counts_query) result = cursor.fetchone()[0] # 1件のデータを入れたため1件の結果を想定 expected = 2 print(\"result:{}\".format(result)) print(\"expected:{}\".format(expected)) > assert result == expected E assert 1 == 2 app/product/test/crud_test.py:18: AssertionError Question2 対象ファイル：app/product/test/crud_test.py 対象関数：test_update テスト内容：登録したデータの「name」を「テストプランからtest99」へ更新しています。期待している値test99と比較し、取得できた値が等しいことを確認します。 エラー内容：テスト内容は「期待値と取得値が等しいこと」を確認したいが、エラーが発生している箇所の構文は「期待値と取得値が等しくないこと」という条件になっている。 cursor = def test_update(cursor): insert_query = \"insert into product_product values('99','テストプラン','これはテストプランです', '99999', '2021-08-18','2021-08-19','createuser','updateuser');\" cursor.execute(insert_query) update_query = \"update product_product set name = 'test99' where code = 99;\" cursor.execute(update_query) select_query = \"select name from product_product where code = 99;\" cursor.execute(select_query) result = cursor.fetchone()[0] expected = 'test99' print(\"result:{}\".format(result)) print(\"expected:{}\".format(expected)) > assert result != expected E AssertionError: assert 'test99' != 'test99' app/product/test/crud_test.py:58: AssertionError Question3 対象ファイル：app/product/test/views_test.py 対象関数：test_render_views テスト内容：リクエストを受けたurlに対して、表示させるtemplate_nameが正しいことを確認し、正常なステータスコード(status_code=200)を返すことを確認しています。 エラー内容：リクエストを受けたurlに対して、正しいテンプレートが選択されていない。(app/product/urls.pyをみてみましょう。以下にも記載しています。) Tips!!! @pytest.mark.django_db：このデコデータを使用する事で、Djangoのテスト用DBを作成し、使用することができます。 @pytest.mark.parametrize：パラメータに設定している引数を、テスト関数に順番に渡してくれます。 client = , param = {'temp_name': 'product:product_create', 'url': '/product/search/'}, get_model = @pytest.mark.django_db @pytest.mark.parametrize('param', [ {'temp_name': 'product:product_create', 'url': '/product/search/'}, {'temp_name': 'product:product_detail', 'url': '/product/detail/1'}, {'temp_name': 'product:product_create', 'url': '/product/create/'}, {'temp_name': 'product:product_update', 'url': '/product/update/1/'} ]) def test_render_views(client, param, get_model): if param['temp_name'] == 'product:product_detail' or \\ param['temp_name'] == 'product:product_update': temp_url = urls.reverse(param['temp_name'], args=(1,)) else: temp_url = urls.reverse(param['temp_name']) print(\"result:{}\".format(temp_url)) print(\"expected:{}\".format(param['url'])) # 正しいテンプレートを使用しているかテスト > assert temp_url == param['url'] E AssertionError: assert '/product/create/' == '/product/search/' E - /product/search/ E ? ^ ^^^ E + /product/create/ E ? ^^ ^^ app/product/test/views_test.py:40: AssertionError app/product/urls.py app_name = 'product' urlpatterns = [ path('', TemplateView.as_view(template_name='product/product_top.html'), name='top'), path('search/', ProductSearchListView.as_view(), name='product_search'), path('detail/', ProductDetailView.as_view(), name='product_detail'), path('create/', CreateProductView.as_view(), name='product_create'), path('update//', ProductUpdateView.as_view(), name='product_update'), ] "},"Section10.html":{"url":"Section10.html","title":"7. Pytest エラーの修正 -回答-","keywords":"","body":"Pytest エラーの修正 -回答- こちらはエラー修正箇所の回答になります。 以下のコードを既存の箇所と置き換えるとすべてのテストがパス（成功）するようになります。 すべて修正できたら、以下のコマンドを実行します。 docker-compose exec web pytest 修正箇所がすべて解消できていれば、現在以下の内容がターミナルに出力されていると思います。 7 passed 回答 Question１ 修正内容：期待値としている箇所 expected では2件となっていたため、期待値が1件となるように expected = 1 と修正する。 def test_create(cursor): insert_query = \"insert into product_product values('99','テストプラン','これはテストプランです', '99999', '2021-08-18','2021-08-19','createuser','updateuser');\" cursor.execute(insert_query) # 件数確認 counts_query = \"select count(1) from product_product;\" cursor.execute(counts_query) result = cursor.fetchone()[0] # 1件のデータを入れたため1件の結果を想定 expected = 1 # 修正箇所 print(\"result:{}\".format(result)) print(\"expected:{}\".format(expected)) assert result == expected Question2 修正内容：構文が誤っていたため、「期待値と取得値が等しいこと」となるように、assert result == expected と修正する。 def test_update(cursor): # 1件のデータを挿入 insert_query = \"insert into product_product values('99','テストプラン','これはテストプランです', '99999', '2021-08-18','2021-08-19','createuser','updateuser');\" cursor.execute(insert_query) # code=99のnameをtest99に変更する update_query = \"update product_product set name = 'test99' where code = 99;\" cursor.execute(update_query) # データ取得 select_query = \"select name from product_product where code = 99;\" cursor.execute(select_query) result = cursor.fetchone()[0] expected = 'test99' # code=99のnameがtest99になっていることを確認 print(\"result:{}\".format(result)) print(\"expected:{}\".format(expected)) assert result == expected # 修正箇所 Question3 修正内容： urls.pyから、 /product/search/ のリクエストに対応する テンプレートは product_search のため、 {'temp_name': 'product:product_search', 'url': '/product/search/'}, となるように修正する。 @pytest.mark.django_db @pytest.mark.parametrize('param', [ {'temp_name': 'product:product_search', 'url': '/product/search/'},　#　修正箇所 {'temp_name': 'product:product_detail', 'url': '/product/detail/1'}, {'temp_name': 'product:product_create', 'url': '/product/create/'}, {'temp_name': 'product:product_update', 'url': '/product/update/1/'} ]) def test_render_views(client, param, get_model): if param['temp_name'] == 'product:product_detail' or \\ param['temp_name'] == 'product:product_update': temp_url = urls.reverse(param['temp_name'], args=(1,)) else: temp_url = urls.reverse(param['temp_name']) print(\"result:{}\".format(temp_url)) print(\"expected:{}\".format(param['url'])) # 正しいテンプレートを使用しているかテスト assert temp_url == param['url'] response = client.get(temp_url) print(\"result:{}\".format(response.status_code)) print(\"expected:{}\".format(200)) # 正しいステータスコードかをテスト assert response.status_code == 200 "},"Section11.html":{"url":"Section11.html","title":"8. 構築環境の掃除","keywords":"","body":"local環境のCleanup 当手順では以下の赤枠部分を実施します。 コンテナの停止 次のコマンドを実行し、コンテナの状態を確認します。 docker ps # CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES # 880cca39ce25 meetup_web \"python3 manage.py r…\" 3 minutes ago Up 3 minutes 0.0.0.0:8000->8000/tcp, :::8000->8000/tcp meetup_web_1 上記で確認できたCONTAINER IDを次のコマンドで利用し、コンテナを停止します。 docker stop [CONTAINER ID] イメージの削除 次のコマンドを実行し、作成したコンテナイメージを確認します。 docker images # REPOSITORY TAG IMAGE ID CREATED SIZE # meetup_web latest 3fb5e3117d67 10 minutes ago 382MB 上記で確認できたIMAGE IDを利用して、ビルドされたイメージを削除します。 docker rmi -f [IMAGE ID] 次のようなメッセージが確認できたら、イメージが正常に削除出来ています。 Untagged: meetup_web... フォルダの削除 最後にフォルダを削除します。 Macの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 ls # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rm -rf xxxxxxxxx Windowsの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 dir # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rd /s /q xxxxxxxxxx 以上。 "}}